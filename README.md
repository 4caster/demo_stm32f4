# Readme.md

## Установка необходимых компонентов
### Шаг 1
[Сайт](https://www.rust-lang.org/tools/install) с инструкциями по установке базовых компонентов Rust

Не забыть добавить в переменную PATH  путь к утилитам Rust.
Удостовериться, что все работает, запуском в терминале 

`rustc --version`

### Шаг 2

Выполнить установку всего  кроме QEMU с [этой](https://doc.rust-lang.org/stable/embedded-book/intro/install/windows.html#arm-none-eabi-gdb) страницы

[Удостовериться](https://doc.rust-lang.org/stable/embedded-book/intro/install/verify.html) в работоспособности

### Шаг 3
Установить утилитки для работы с бинарями. Будет использоваться для конвертации elf->bin

`cargo install cargo-binutils`

### Шаг 4

Установить 

`rustup component add llvm-tools-preview`

### Шаг 5

Установить и установить расширения для VSCode+Rust

## Создание проекта
### Шаг 1

Через терминал (использовался PowerShell) перейти в папку, где будет располагаться проект

 ### Шаг 2 -  Создать проект
 
 Создать проект
 
`cargo new <имя проекта>`

Будет создан пустой проект для компиляции RUST проекта. Для работы с МК нужно указать распределение памяти и прописать зависимости

### Шаг 3 - настройка проекта
#### Ступень 1
Открыть проект в VSCode 

`cd <имя проекта>; code .`
#### Ступень 2
Создать внутри проекта директорию ".cargo" 

В папке создать файл "config"

Подробнее о содержание папки config можно прочитать в документации, предлагаю скопировать этот файл из репозитория.

Самое главное - обратить внимание на выбор target - оно должен быть подобрано под ядро.

	# target = "thumbv6m-none-eabi"    # Cortex-M0 and Cortex-M0+
	# target = "thumbv7m-none-eabi"    # Cortex-M3
	# target = "thumbv7em-none-eabi"   # Cortex-M4 and Cortex-M7 (no FPU)
	# target = "thumbv7em-none-eabihf" # Cortex-M4F and Cortex-M7F (with FPU)

После определения своего ядра необходимо добавить target в rustup

`rustup target add <target name>`
#### Ступень 2
В корне проекта создать файл memory.x. В нем содержаться адреса памяти платформы. Зависит от контроллера, вписывать свои. Базовая структура - на гите

Открыть файл  Cargo.toml. Для сборки под МК его содержимое относительно обширно и содержит основные зависимости для сборки проекта. Главное, на что нужно обратить внимание:

	[dependencies.stm32f4xx-hal]
	version = "0.8.3"
	features = ["stm32f407", "rt"]
Сюда нужно вставить соответствующий контроллеру крейт, выбрать версию и конкретизировать контроллер. "rt" не трогать. Список крейтов можно найти на сайтах [тут](https://crates.io/) и [тут](https://docs.rs/). В поиске вводим stm32f*xx-hal, и выбираем подходящую версию
#### Ступень 3
В первый предлагаю воспользоваться примером, который предоставляет крейт stm32f4xx-hal. Для F4 пример мигания светодиодом лежит [тут](https://docs.rs/crate/stm32f4xx-hal/0.8.3/source/examples/delay-blinky.rs). Копируем содержимое в main.rs. 

В 22 и 23 строчке находятся имена регистров GPIO и номер пина. Их нужно изменить под себя. В stm32f4 discovery светодиоды расположены на пинах pd12-pd15

        let gpiod = dp.GPIOD.split(); 
        let mut led = gpiod.pd12.into_push_pull_output(); 

## Компиляция

### Способ 1 - cargo build
В терминале открываем папку проект и вводим

`cargo build`

В 

`.\target\<target name>\debug `

появляется файл 

`demo_stm32f4`

 Его можно загрузить через gdb. 
 
 ### Способ 2 - cargo objcopy 
 Этот способ позволяет создавать бинарный файл прошивки в корне проекта. Команда выглядит следующим образом:
 
 `cargo objcopy --bin <demo_stm32f4> --target thumbv7m-none-eabi -- -O binary demo_stm32f4.bin`
 
 
 Также сделал небольшие таски для билда и загрузке через ST-LINK_CLI. Его нужно будет изменить под имя вашего бинарного файла

`ctrl+shift+b` - вызвать панель тасков

`cargo build` - собрать проект с формированием бинаря

`cargo run` - прошить плату

